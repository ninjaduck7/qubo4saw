import numpy as np
import matplotlib.pyplot as plt

def draw_hexagonal_system_and_save(binary_string, save_path):
    
     # Set the figure size
    fig_width = 21
    fig, ax = plt.subplots(figsize=(fig_width, fig_width))

    # 设置网格参数
    N = 121
    ratio_y = np.sqrt(3) / 2  # cos(60°)
    N_Y = int(np.sqrt(N) / ratio_y)
    N_X = N // N_Y

    # 生成六边形网格的点
    xv, yv = np.meshgrid(np.arange(N_X), np.arange(N_Y), sparse=False, indexing='xy')
    yv = yv * ratio_y
    xv = xv.astype(float)  # 将xv数组转换为float类型
    xv[::2, :] += 0.5    # 平移奇数行

    
    edges = {
            'x_inner_12': ((6.5, 5.196152422706632), (6.0, 6.06217782649107)),
            'x_inner_23': ((6.0, 6.06217782649107), (5.0, 6.06217782649107)),
            'x_inner_34': ((5.0, 6.06217782649107), (4.5, 5.196152422706632)),
            'x_inner_45': ((4.5, 5.196152422706632), (5.0, 4.330127018922194)),
            'x_inner_56': ((5.0, 4.330127018922194), (6.0, 4.330127018922194)),
            'x_inner_61': ((6.0, 4.330127018922194), (6.5, 5.196152422706632)),
            'x_tunnel_1': ((6.5, 5.196152422706632), (7.5, 5.196152422706632)),
            'x_tunnel_2': ((6.0, 6.06217782649107), (6.5, 6.928203230275509)),
            'x_tunnel_3': ((5.0, 6.06217782649107), (4.5, 6.928203230275509)),
            'x_tunnel_4': ((4.5, 5.196152422706632), (3.5, 5.196152422706632)),
            'x_tunnel_5': ((5.0, 4.330127018922194), (4.5, 3.4641016151377553)),
            'x_tunnel_6': ((6.0, 4.330127018922194), (6.5, 3.4641016151377553)),
            'x_1_outer_1': ((7.5, 5.196152422706632), (8.0, 4.330127018922194)),
            'x_1_outer_2': ((7.5, 5.196152422706632), (8.0, 6.06217782649107)),
            'x_2_outer_1': ((6.5, 6.928203230275509), (7.5, 6.928203230275509)),
            'x_2_outer_2': ((6.5, 6.928203230275509), (6.0, 7.794228634059947)),
            'x_3_outer_1': ((4.5, 6.928203230275509), (5.0, 7.794228634059947)),
            'x_3_outer_2': ((4.5, 6.928203230275509), (3.5, 6.928203230275509)),
            'x_4_outer_1': ((3.5, 5.196152422706632), (3.0, 6.06217782649107)),
            'x_4_outer_2': ((3.5, 5.196152422706632), (3.0, 4.330127018922194)),
            'x_5_outer_1': ((4.5, 3.4641016151377553), (3.5, 3.4641016151377553)),
            'x_5_outer_2': ((4.5, 3.4641016151377553), (5.0, 2.598076211353317)),
            'x_6_outer_1': ((6.5, 3.4641016151377553), (6.0, 2.598076211353317)),
            'x_6_outer_2': ((6.5, 3.4641016151377553), (7.5, 3.4641016151377553)),
            'x_random_12': ((8.0, 6.06217782649107), (7.5, 6.928203230275509)),
            'x_random_23': ((6.0, 7.794228634059947), (5.0, 7.794228634059947)),
            'x_random_34': ((3.5, 6.928203230275509), (3.0, 6.06217782649107)),
            'x_random_45': ((3.0, 4.330127018922194), (3.5, 3.4641016151377553)),
            'x_random_56': ((5.0, 2.598076211353317), (6.0, 2.598076211353317)),
            'x_random_66': ((7.5, 3.4641016151377553), (8.0, 4.330127018922194)),
        }




    # 绘制网格中的所有点之间的连接（黑色线段）
    for j in range(N_Y):
        for i in range(N_X):
            # 连接右边的点
            if i < N_X - 1:
                ax.plot([xv[j, i], xv[j, i + 1]], [yv[j, i], yv[j, i + 1]], color='black', linestyle='-', linewidth=0.5)
            # 连接上面的点
            if j < N_Y - 1:
                ax.plot([xv[j, i], xv[j + 1, i]], [yv[j, i], yv[j + 1, i]], color='black', linestyle='-', linewidth=0.5)
            # 连接右上方的点（适用于奇数行）
            if i < N_X - 1 and j < N_Y - 1 and j % 2 == 0:
                ax.plot([xv[j, i], xv[j + 1, i + 1]], [yv[j, i], yv[j + 1, i + 1]], color='black', linestyle='-', linewidth=0.5)
            # 修正右上连接，避免把最上面最下面的点也连接起来
            if i < N_X - 1 and j > 0 and j % 2 == 0:
                ax.plot([xv[j, i], xv[j - 1, i + 1]], [yv[j, i], yv[j - 1, i + 1]], color='black', linestyle='-', linewidth=0.5)
        
    # 绘制激活的边
    for idx, key in enumerate(edges):
        if idx < len(binary_string) and binary_string[idx] == '1':
            ((x1, y1), (x2, y2)) = edges[key]
            ax.plot([x1, x2], [y1, y2], 'bo-', linewidth=2)  # 激活的边为蓝色

    ax.set_aspect('equal')
    ax.axis('off')
   
   
    plt.savefig(save_path)  # 保存图片
